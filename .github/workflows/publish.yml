# This workflow automates the publication of a new script release.
# It supports two trigger mechanisms:
# 1. A new release is published with a tag in the format "script-name-vX.Y.Z".
# 2. A manual trigger from the GitHub Actions UI to republish all scripts.
name: Publish Script

# Controls when the workflow is triggered.
on:
  # Triggered when a new release is published.
  release:
    types: [published]
  # Allows manual triggering from the GitHub Actions UI.
  workflow_dispatch:

# Defines a single job that will run on an Ubuntu environment.
jobs:
  publish-script:
    runs-on: ubuntu-latest

    # We need to give the job permissions to write to other repos.
    permissions:
      contents: write

    steps:
      - name: Checkout main scripts repo
        uses: actions/checkout@v3
        with:
          path: scripts
          # Fetch all history and tags to find previous versions
          fetch-depth: 0

      - name: Checkout Homebrew tap repo
        uses: actions/checkout@v3
        with:
          repository: jmerhar/homebrew-scripts
          path: homebrew-scripts
          token: ${{ secrets.PAT }}

      - name: Checkout APT repo
        uses: actions/checkout@v3
        with:
          repository: jmerhar/apt-scripts
          path: apt-scripts
          token: ${{ secrets.PAT }}

      - name: Setup Git for multi-repo push
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Prepare Environment Variables
        run: |
          echo "PKGSCR_HOMEBREW_FORMULA_DIR=$(pwd)/dist/homebrew" >> $GITHUB_ENV
          echo "PKGSCR_DEB_PACKAGE_DIR=$(pwd)/dist/debian" >> $GITHUB_ENV
          echo "PKGSCR_CONFIG_DIR=$(pwd)/scripts/conf" >> $GITHUB_ENV

      - name: Package Scripts
        id: package
        run: |
          set -e
          # --- Single Script Release (from tag) ---
          if [[ "${{ github.event_name }}" == "release" ]]; then
            TAG="${{ github.event.release.tag_name }}"
            echo "--- Processing release for tag: ${TAG} ---"

            # Validate tag format and extract script name and version
            if [[ ! "${TAG}" =~ ^([a-zA-Z0-9_-]+)-v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
              echo "::error::Tag format is invalid. Expected 'script-name-vX.Y.Z', but got '${TAG}'."
              exit 1
            fi

            SCRIPT_NAME="${BASH_REMATCH[1]}"
            VERSION="v${BASH_REMATCH[2]}"
            TARBALL_URL="${{ github.event.release.tarball_url }}"
            CHECKSUM=$(curl -sSL "${TARBALL_URL}" | shasum -a 256 | awk '{print $1}')

            # Find the path to the script file, excluding the conf directory
            pushd scripts
            SCRIPT_PATH=$(find . -type f -name "${SCRIPT_NAME}.*" -not -path "./conf/*" | head -n 1)
            if [[ -z "${SCRIPT_PATH}" ]]; then
              echo "::error::Could not find a script file for '${SCRIPT_NAME}'."
              exit 1
            fi
            popd

            # Run the packaging script with version-specific variables
            env \
              PKGSCR_VERSION="${VERSION}" \
              PKGSCR_TARBALL_URL="${TARBALL_URL}" \
              PKGSCR_SHA256_CHECKSUM="${CHECKSUM}" \
              ./scripts/system/package-script.sh "scripts/${SCRIPT_PATH}"

            # Set a specific commit message for the release
            echo "commit_message=feat(${SCRIPT_NAME}): Release version ${VERSION}" >> $GITHUB_OUTPUT
          fi

          # --- Republish All Scripts (manual trigger) ---
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "--- Republishing latest version of all scripts ---"
            pushd scripts
            # Find all files in subdirectories, excluding conf and .github.
            find . -mindepth 2 -type f -not -path "./conf/*" -not -path "./.github/*" | while read script_path; do
              # Check if the file starts with a shebang to identify it as a script.
              if ! head -n 1 "${script_path}" | grep -qE '^#!'; then
                echo "--- Skipping non-script file: ${script_path} ---"
                continue
              fi

              script_name=$(basename "${script_path}" | cut -d. -f1)

              # Find the latest version tag for this specific script
              latest_tag=$(git tag --list "${script_name}-v*" --sort=-v:refname | head -n 1)

              if [[ -n "${latest_tag}" ]]; then
                echo "--- Packaging script: ${script_name}, latest tag: ${latest_tag} ---"
                version=$(echo "${latest_tag}" | grep -o 'v[0-9]\+\.[0-9]\+\.[0-9]\+')
                tarball_url="https://github.com/${{ github.repository }}/archive/refs/tags/${latest_tag}.tar.gz"
                checksum=$(curl -sSL "${tarball_url}" | shasum -a 256 | awk '{print $1}')

                # Run package-script with specific env vars for this script and version
                env \
                  PKGSCR_VERSION="${version}" \
                  PKGSCR_TARBALL_URL="${tarball_url}" \
                  PKGSCR_SHA256_CHECKSUM="${checksum}" \
                  ./system/package-script.sh "${script_path}"
              else
                echo "--- Skipping script ${script_name}: No version tags found. ---"
              fi
            done
            popd

            # Set a generic commit message for the republish action
            echo "commit_message=chore: Republish latest version of all scripts" >> $GITHUB_OUTPUT
          fi

      - name: Move Artifacts to Repositories
        # Only run if artifacts were actually created
        if: success() && (steps.package.outputs.commit_message != '')
        run: |
          # Move Homebrew formulas
          if [ -d "dist/homebrew" ]; then
            mv dist/homebrew/*.rb homebrew-scripts/Formula/
          fi
          # Move Debian packages
          if [ -d "dist/debian" ]; then
            mv dist/debian/*.deb apt-scripts/pool/main/
          fi

      - name: Commit and push Homebrew changes
        if: success() && (steps.package.outputs.commit_message != '')
        run: |
          cd homebrew-scripts
          git add .
          git commit -m "${{ steps.package.outputs.commit_message }}" || echo "No Homebrew changes to commit."
          git push

      - name: Sign and commit APT repository changes
        if: success() && (steps.package.outputs.commit_message != '')
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd apt-scripts
          # Import GPG key
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import --passphrase "$GPG_PASSPHRASE"
          # Generate package files
          dpkg-scanpackages --arch=all pool/ > dists/stable/main/binary-all/Packages
          gzip -c dists/stable/main/binary-all/Packages > dists/stable/main/binary-all/Packages.gz
          # Generate release file
          apt-ftparchive -c apt-ftparchive.conf release dists/stable/ > dists/stable/Release
          # Verify release file
          test -s dists/stable/Release || (echo "::error::Failed to generate valid Release file." && exit 1)
          # Sign the release file
          rm -f dists/stable/InRelease
          gpg --batch --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --default-key "jmerhar-bot" --clearsign -o dists/stable/InRelease dists/stable/Release
          # Commit and push
          git add .
          git commit -m "${{ steps.package.outputs.commit_message }}" || echo "No APT changes to commit."
          git push

