#!/bin/bash
#
# A generic package-file generator designed to be run from a CI/CD workflow.
#
# It takes the path to a script as an argument, parses metadata from a
# corresponding README.md file (expected in the same directory), and generates
# the necessary package files (.rb for Homebrew and .deb for Debian).
#
# The script is configured entirely through environment variables and places its
# output into local directories specified by those variables, decoupling it
# from any specific repository structure.
#
# Usage:
#   ./publish-script.sh <path-to-script>
#
# Environment variables:
#   - HOMEPAGE_URL: The URL for the project's homepage.
#   - HOMEBREW_FORMULA_DIR: Local output directory for Homebrew formula files.
#   - DEB_PACKAGE_DIR: Local output directory for Debian package files.
#   - MAINTAINER_INFO: Maintainer's name and email for Debian packages.
#   - TARBALL_URL: URL to the new release tarball.
#   - VERSION: The version string (e.g., "v1.0.1").
#   - SHA256_CHECKSUM: The checksum of the tarball.

set -o errexit
set -o nounset

#######################################
# Prints a timestamped error message to stderr for runtime errors.
# Globals:
#   None
# Arguments:
#   Message to print.
# Outputs:
#   Writes timestamped message to stderr.
#######################################
log_error() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: Error: $*" >&2
}

#######################################
# Prints the script's usage instructions to stdout.
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   Writes usage text to stdout.
#######################################
show_usage() {
  local script_basename
  script_basename=$(basename "$0")
  echo "Usage: ${script_basename} <path-to-script>"
  echo "Example: ${script_basename} utility/unlock-pdf.sh"
}

#######################################
# Parses the script path to set global script and name variables.
# Arguments:
#   Path to the script to be published.
# Outputs:
#   Sets source_script_path, readme_path, and script_name global variables.
#######################################
parse_script_info() {
  source_script_path="$1"
  script_name=$(basename "${source_script_path%.*}")
  # Assumes README is in the same directory as the script.
  readme_path="$(dirname "${source_script_path}")/README.md"
}

#######################################
# Parses the script's README for its description and dependencies.
# Globals:
#   readme_path
#   script_name
# Arguments:
#   None
# Outputs:
#   Sets description and dependencies global variables.
#######################################
parse_readme() {
  echo "Parsing README.md for description and dependencies..."

  if [[ ! -f "${readme_path}" ]]; then
    log_error "README.md not found at '${readme_path}'"
    exit 1
  fi

  description=$(awk -v script_heading="### \`*${script_name}.*\`*" '
    BEGIN {found=0}
    $0 ~ script_heading {found=1; next}
    found && !/^[[:space:]]*$/ {
      desc=$0;
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", desc);
      print desc;
      exit
    }
  ' "${readme_path}")

  if [[ -z "${description}" ]]; then
    log_error "Could not find description for '${script_name}' in README.md."
    exit 1
  fi

  dependencies=$(awk '
    /^#### Dependencies/ { in_deps = 1; next }
    in_deps && /^-/ {
      if (match($0, /`[^`]+`/)) {
        dep = substr($0, RSTART + 1, RLENGTH - 2);
        if (length(dep) > 0) printf "  depends_on \"%s\"\n", dep;
      }
    }
    in_deps && !/^-/ { in_deps = 0 }
  ' "${readme_path}")
}

#######################################
# Generates the Homebrew formula file.
# Globals:
#   HOMEBREW_FORMULA_DIR, script_name, HOMEPAGE_URL,
#   TARBALL_URL, SHA256_CHECKSUM, dependencies, source_script_path
# Arguments:
#   None
#######################################
generate_homebrew_formula() {
  mkdir -p "${HOMEBREW_FORMULA_DIR}"
  local formula_file="${HOMEBREW_FORMULA_DIR}/${script_name}.rb"
  local class_name
  class_name=$(echo "${script_name}" | awk -F'-' '{
    for (i=1; i<=NF; i++) {
      printf "%s", toupper(substr($i,1,1)) substr($i,2)
    }
    print ""
  }')

  echo "Creating or updating Homebrew formula: ${formula_file}"

  cat > "${formula_file}" <<EOF
# This file was generated by the publish-script.sh script.
class ${class_name} < Formula
  desc "${description}"
  homepage "${HOMEPAGE_URL}"
  url "${TARBALL_URL}"
  sha256 "${SHA256_CHECKSUM}"

${dependencies}

  def install
    bin.install "${source_script_path}" => "${script_name}"
  end
end
EOF
}

#######################################
# Generates the Debian (.deb) package.
# Globals:
#   DEB_PACKAGE_DIR, script_name, VERSION, source_script_path, dependencies,
#   MAINTAINER_INFO, description
# Arguments:
#   None
# Returns:
#   0 if successful, 1 on failure.
#######################################
generate_deb_package() {
  echo "Generating Debian (.deb) package..."

  if ! command -v dpkg-deb &> /dev/null; then
    log_error "'dpkg-deb' not found. Skipping .deb package generation."
    return 1
  fi

  local deb_version="${VERSION#v}"
  local package_dir="${DEB_PACKAGE_DIR}/${script_name}-${VERSION}"
  local control_dir="${package_dir}/DEBIAN"
  local bin_dir="${package_dir}/usr/local/bin"
  local deb_file="${DEB_PACKAGE_DIR}/${script_name}_${deb_version}_all.deb"

  mkdir -p "${DEB_PACKAGE_DIR}"
  rm -rf "${package_dir}"
  mkdir -p "${control_dir}" "${bin_dir}"

  local deb_depends
  deb_depends=$(echo "${dependencies}" | sed 's/  depends_on "//g; s/"//g' | tr '\n' ',' | sed 's/,$//')

  cat > "${control_dir}/control" <<EOF
Package: ${script_name}
Version: ${deb_version}
Section: utils
Priority: optional
Architecture: all
Depends: ${deb_depends}
Maintainer: ${MAINTAINER_INFO}
Description: ${description}
 This package installs the '${script_name}' script.
EOF

  cp "${source_script_path}" "${bin_dir}/${script_name}"
  chmod +x "${bin_dir}/${script_name}"

  echo "Building .deb package..."
  dpkg-deb --build "${package_dir}" "${deb_file}"
  rm -rf "${package_dir}"

  if [[ -f "${deb_file}" ]]; then
    echo "Debian package created successfully: ${deb_file}"
  else
    log_error "Failed to create Debian package."
    return 1
  fi
}

main() {
  if (( $# != 1 )); then
    log_error "Missing required script path argument."
    show_usage
    exit 1
  fi

  parse_script_info "$1"
  parse_readme
  generate_homebrew_formula
  generate_deb_package
}

main "$@"

